# Практическая работа 3
В практической работе есть обязательные и дополнительные задачи.

_Обязательные задачи_ помогут проверить, как вы усвоили материал модуля. Их нужно сдать на проверку куратору.

_Дополнительные задания_ выполнять необязательно. Они подойдут тем, кто хочет ещё немного потренироваться, решая задачи по программированию. Вы также можете отправить их на проверку и получить обратную связь от куратора.

## Цели практической работы
- Изучить на практике культуры CI.
- Попрактиковаться в написании модульных тестов.
- Научиться находить «узкие» места в коде.

## Что входит в работу
1. Обязательные задачи:
   - Хорошего дня!
   - Дешифратор.
   - Учёт финансов.
   - Доверяй, но проверяй.
2. Дополнительная задача:
   - Система сборки.

## Задача 1. Хорошего дня!
### Что нужно сделать
Мы кое-что забыли проверить, когда писали тест `test_can_get_correct_username_with_weekdate`: добавьте проверку корректности вернувшегося дня недели.
### Советы и рекомендации
- Что будет, если программа выдаёт неправильный день недели, а в `username` передать строку 'Хорошей среды'?
- Тестировать только сегодняшний день будет неправильным — вдруг у программы семь пятниц на неделе. Но как это сделать, если получение дня недели происходит в самой тестируемой функции? В этом поможет библиотека [freezegun](https://github.com/spulec/freezegun).
### Что оценивается
- Для тестирования вернувшегося дня недели создана отдельная функция.
- Обрабатывается случай, когда в username вводится пожелание хорошего дня.

## Задача 2. Дешифратор
### Что нужно сделать
Чтобы повысить уровень доверия Пети к нашему дешифратору из предыдущего модуля, напишите тесты на все проверки, которые есть в задании:

| Шифровка                         | Расшифровка     |
|----------------------------------|-----------------|
| абра-кадабра.                    | абра-кадабра    |
| абраа..-кадабра                  | абра-кадабра    |
|  абраа..-.кадабра |  абра-кадабра   |
| абра--..кадабра | абра-кадабра    |
| абрау...-кадабра | абра-кадабра    |
| абра........ | <пустая строка> |
| абр......a. | a               |
| 1..2.3 | 23              |
| . | <пустая строка> |
| 1....................... | <пустая строка> |

### Советы и рекомендации
Разбейте эти тесты на группы по количеству точек в шифре. 
Это можно сделать отдельными функциями. Можно также воспользоваться менеджером контекста [subTest()](https://docs.python.org/3/library/unittest.html#distinguishing-test-iterations-using-subtests).
### Что оценивается
Тесты логически сгруппированы и покрывают все случаи из условия.

## Задача 3. Учёт финансов
### Что нужно сделать
К деньгам стоит подходить ответственно, поэтому давайте протестируем наше приложение «Учёт финансов» из предыдущего модуля:

- Заполните `storage` изначальными данными, с которыми вы будете работать в каждом тесте.
- Проверьте, что endpoint `/add/` работает.
- Проверьте, что оба endpoints `/calculate/` работают.
- Проверьте, что endpoint `/add/` может принять дату только в формате _YYYYMMDD_, а при подаче невалидного значения что-то идёт не так. Нужно добиться такого условия, при котором endpoint свалится с ошибкой.
- Проверьте, как будут работать endpoints `/calculate/`, если в `storage` ничего нет.

### Советы и рекомендации
- Проверить, порождает ли какое-то действие исключение, можно с помощью менеджера контекста `assertRaises`:

```python
with self.assertRaises(TypeError):
    add('ymd')
```
- Создавать общие для всех тестов данные лучше в методе setUpClass.
```python
@classmethod
def setUpClass(cls):
    storage.update(...)
```

### Что оценивается
На каждый endpoint сделано хотя бы по три теста.

## Задача 4. Доверяй, но проверяй
### Что нужно сделать
Каждый разработчик ещё и тестировщик: он должен уметь покрыть тестами свой код. Но бывают ситуации, когда он не успевает и просит помочь в этом деле своего товарища тестировщика. Вот и сейчас так получилось: код есть, но тестами он не покрыт. Да и, кажется, писался он впопыхах пальцем левой ноги, надо бы его проверить.

1. Покройте данный класс юнит-тестами: все методы должны быть проверены.
2. Используя написанные тесты, найдите ошибки и исправьте их.
3. Найденные ошибки и их исправления оформите в виде Markdown-файла _ERRORS.MD_.

```python

class Person:
    def __init__(self, name: str, year_of_birth: int, address: str = '') -> None:
        self.name: str = name
        self.yob: int = year_of_birth
        self.address: str = address

    def get_age(self) -> int:
        now: datetime.datetime = datetime.datetime.now()
        return self.yob - now.year

    def get_name(self) -> str:
        return self.name

    def set_name(self, name: str) -> None:
        self.name = self.name

    def set_address(self, address: str) -> None:
        self.address == address

    def get_address(self) -> str:
        return self.address

    def is_homeless(self) -> bool:
        '''
        returns True if address is not set, false in other case
        '''
        return address is None

```
### Советы и рекомендации
[Подсказка по Markdown-синтаксису](https://github.com/OlgaVlasova/markdown-doc/blob/master/README.md)
### Что оценивается
- Написан тест для каждого метода.
- Найдены и исправлены все ошибки.
- Ответ оформлен в виде Markdown-файла.

## Задача 5. Система сборки (выполните по желанию)
### Что нужно сделать
Напишите bash-скрипт для задания №2, который при запуске выполнит следующие действия:

1. Проверит код программы с помощью статического анализатора [pylint](https://pylint.pycqa.org/en/latest/tutorial.html).<br>Результат должен сохраняться в JSON-файл, а в консоль должны выводиться отчёт и метрика качества кода.
2. Запустит юнит-тесты для программы.
3. Если предыдущие шаги выполнены успешно, выведет сообщение ОК, иначе — «Имеются ошибки».

Сделайте несколько ошибок в коде, чтобы посмотреть, как меняется вывод.

### Советы и рекомендации
- [Шпаргалка по написанию bash-скриптов](https://gist.github.com/Titiaiev/dcb7298389d1276b823bbc96e29f940d)
- Библиотека `pylint` позволяет проверить исходный код, найти ошибки и оценить качество написанной программы. Установка:

`pip3 install pylint`

Запуск:

`pylint program.py`

Вам пригодятся несколько флагов: [output-format](https://pylint.pycqa.org/en/latest/user_guide/usage/output.html?highlight=output-format#output-options), [reports](https://pylint.pycqa.org/en/latest/user_guide/usage/output.html#reports-section), [score](https://pylint.pycqa.org/en/latest/user_guide/usage/output.html#score-section).
- `subTest` принимает в качестве входных параметров сообщение и именованные аргументы.

```python
for i range(10):
    with self.subTest('Test message' , n=i):
        self.assertEqual(expected, output)
```
`FAIL: test_decrypt (test_decrypt.DecryptTestCase) [Test message] (n=2)`

- Если при запуске скрипта выводится ошибка Permission denied, нужно дать этому файлу разрешение на запуск:

```
$ ./script.sh
Permission denied: ./script.sh
$ chmod u+x ./script.sh
$ ./script.sh
```
- Пример определения кода возврата:

```shell
pylint file.py
pylint_res=$?
if [[ pylint_res -eq 0 ]]; then
  echo 'Pylint OK'
else
  echo 'Pylint not OK'
fi
```
[Про коды возврата в Pylint](https://pylint.pycqa.org/en/latest/user_guide/usage/run.html#exit-codes)
### Что оценивается
- Формат вывода статического анализатора соответствует условию.
- Написан работающий bash-скрипт, с помощью которого запускаются статический анализатор и тесты.
- Внутри скрипта делается проверка кодов возврата исполненных команд.

## Советы и рекомендации (общее)
- Помимо `assertTrue` в `unittest.TestCase` есть и [другие методы](https://docs.python.org/3/library/unittest.html#unittest.TestCase.debug).
- Обратите внимание, что `setUp` запускается перед каждым тестом, а `tearDown` — после каждого теста. Чтобы подготовить общие данные для набора тестов или для запуска тестового клиента, стоит использовать `setUpClass` и `tearDownClass`.
- Хорошей практикой считается создание docstring'ов к тестам. Это описание будет отображаться при запуске unit-тестов и будет служить неплохой документацией к тестируемым методам.

## Что оценивается в практической работе
- Тестируется «защита от дурака» — реакция программы на очевидно неверные действия человека.
- Для тестирования Flask-приложений используется тестовый клиент.
- Тестовые случаи (`unittest.TestCase`) и наборы тестов (тестирующие функции) имеют значащие имена.

## Как отправить работу на проверку
Выполните домашнее задание в GitLab, напишите «Сделано» в форме ниже и нажмите кнопку «Отправить».

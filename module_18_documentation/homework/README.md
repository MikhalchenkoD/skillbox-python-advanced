# Практическая работа. Модуль 18
## Цели практической работы
* Применить спецификацию документирования Swagger.
* Научиться создавать документацию к API с помощью модуля `flasgger`.
* Закрепить знания по работе с модулем `requests`.
* Применить протокол JSON-RPC.

## Что входит в практическую работу
1. Создать документацию к API.
2. Проанализировать скорость работы API.
3. Создать калькулятор JSON-RPC.

## Задача 1. Создание документации к API
### Что нужно сделать
1. Добавьте документацию для ресурсов, которые реализовали в практической работе прошлого модуля.
2. Напишите спецификацию для api/books/ в формате YAML, а для `api/authors/` — в формате JSON или Python-словаря.
3. Если в прошлом модуле вы использовали `Flask-RESTX`, можете применить возможности этой библиотеки по созданию Swagger-документации. Узнать о них подробнее можно [в этой статье](https://flask-restx.readthedocs.io/en/latest/swagger.html).

### Советы и рекомендации
* Документацию можно оформлять в отдельных файлах формата `.yml` и подключать её при помощи функции `swag_from`. Подробнее об этом можно прочитать [в этой статье](https://github.com/flasgger/flasgger#using-external-yaml-files).
* Вы можете использовать [Python-словарь](https://github.com/flasgger/flasgger#using-dictionaries-as-raw-specs) в качестве документации. Попробуйте создать свою обёртку над `swag_from`, чтобы можно было использовать отдельные JSON-файлы вместо словарей.

### Что оценивается
* Спецификация для ресурса книг написана в формате YAML.
* Спецификация для ресурса авторов написана в формате JSON или Python-словаря.

## Задача 2. Анализ скорости работы API
### Что нужно сделать
1. Дополните класс-клиент API методами для работы с новыми endpoints.
2. Исследуйте, насколько быстрее работает код с использованием сессии и обычных методов `post`/`get` для 10, 100, 1000 запросов.
3. Если вы выполните это задание сразу, то не заметите значительной разницы. Дело в том, что сервер, который обрабатывает запрос, убивает соединение сразу после того, как отправит его клиенту. Вы можете убедиться в этом, включив уровень `DEBUG` в корневом логгере:
    ```python
    import logging
    logging.basicConfig(level=logging.DEBUG)
    ```
4. Чтобы исправить поведение сервера, внесите дополнительную настройку перед `app.run()`:
    ```python
    from werkzeug.serving import WSGIRequestHandler
    WSGIRequestHandler.protocol_version = "HTTP/1.1"
    ```
5. Проведите восемь испытаний для каждого количества запросов:
   * с использованием (+O) и без использования (–O) дополнительной настройки;
   * с использованием (+S) и без использования (–S) сессии;
   * с использованием (+T) и без использования (–T) параллельных запросов с помощью многопоточности (например, `ThreadPool`).

6. Занесите время работы в каждом испытании в таблицу. Её шаблон размещён в файле `REPORT.md` в папке с заданием.

```text
+----------------+-------------------------------------------+---------------------------------------------+
| Число запросов |                     -O                    |                      +O                     |
|                +---------------------+---------------------+---------------------+-----------------------+
|                |          -S         |          +S         |          -S         |           +S          |
|                +----------+----------+----------+----------+----------+----------+-----------+-----------+
|                |    -T    |    +T    |    -T    |    +T    |    -T    |    +T    |     -T    |     +T    |
+----------------+----------+----------+----------+----------+----------+----------+-----------+-----------+
|      10        |          |          |          |          |          |          |           |           |
+----------------+----------+----------+----------+----------+----------+----------+-----------+-----------+
|      100       |          |          |          |          |          |          |           |           |
+----------------+----------+----------+----------+----------+----------+----------+-----------+-----------+
|      1000      |          |          |          |          |          |          |           |           |
+----------------+----------+----------+----------+----------+----------+----------+-----------+-----------+
```

### Что оценивается
* Таблица с результатами заполнена полностью.
* Для параллельных запросов используются потоки, а не процессы.
* Отправка запросов для исследования вынесена в отдельный класс для более удобной настройки параметров:
   * количество запросов, 
   * использование сессии, 
   * использование многопоточности.

## Задача 3. Создание калькулятора JSON-RPC
### Что нужно сделать
1. Напишите калькулятор на базе JSON-RPC для двух переменных. Он должен поддерживать базовые операции:
   * сложение,
   * вычитание,
   * умножение
   * деление.
2. Оформите документацию для него.

### Советы и рекомендации
* Вы можете опираться на пример реализации простого приложения с использованием библиотеки [Flask JSON-RPC](https://github.com/cenobites/flask-jsonrpc). Он описан [в этой статье](https://habr.com/ru/post/440944/).
* Для аннотации методов в документации используйте [ключевое слово enum](https://swagger.io/docs/specification/data-models/enums/).

### Что оценивается
* Приложение реализовано по спецификации JSON-RPC.
* Предусмотрена обработка ошибок и возвращение соответствующего кода состояния HTTP.
* Присутствует документация к написанному endpoint.

## Общие советы и рекомендации
Выполнить задания вам помогут следующие ресурсы:

* Официальная документация [flasgger](https://github.com/flasgger/flasgger).
* Статья [Swagger documentation](https://flask-restx.readthedocs.io/en/latest/swagger.html).
* Спецификация [Swagger](https://swagger.io/specification/).
* Спецификация [JSON-RPC](https://www.jsonrpc.org/specification).

## Что оценивается в практической работе
* Написанная документация соответствует [спецификации Swagger](https://swagger.io/specification/).
* Описание передаваемых параметров и возвращаемых результатов осмысленно и понятно.
* Названия переменных, функций и классов имеют значимые имена.

# Практическая работа 2
## Цель практической работы
Научиться:
- работать с основными командами Linux;
- писать простые консольные утилиты на Python;
- обрабатывать переданные в URL параметры разных типов;
- возвращать пользователю форматированный текст с помощью HTML-тегов.

## Что входит в работу
- Задача 1. Список процессов.
- Задача 2. Средний размер файла.
- Задача 3. Дешифратор.
- Задача 4. Хорошего дня!
- Задача 5. Максимальное число.
- Задача 6. Превью файла.
- Задача 7. Учёт финансов.

## Задача 1. Список процессов
### Что нужно сделать
С помощью команды ps можно посмотреть список запущенных процессов.<br>
С флагами `aux` эта команда выведет информацию обо всех процессах, запущенных в системе.

Запустите эту команду и сохраните выданный результат в файл:

`$ ps aux > output_file.txt`

Столбец RSS показывает информацию о потребляемой памяти в байтах.

Напишите функцию `get_summary_rss`, которая на вход принимает путь до файла с результатом выполнения команды `ps aux`, а возвращает суммарный объём потребляемой памяти в человекочитаемом формате. Это означает, что ответ надо перевести в байты, килобайты, мегабайты и так далее.
### Советы и рекомендации
- Для разбиения строки по столбцам можно воспользоваться функцией split без аргументов:

```python
columns = line.split()
```

- Так как первой строкой является заголовок, её можно отбросить при расчётах суммарного объёма потребляемой памяти. Это можно сделать, например, с помощью среза:

```python
lines = output_file.readlines()[1:]
```

### Что оценивается
- Результат выводится в человекочитаемом формате (Б, KiB, MiB, …).
- Путь к файлу вынесен в отдельную переменную.
- Запуск функции происходит в блоке `__main__`.

## Задача 2. Средний размер файла
### Что нужно сделать
Удобно направлять результат выполнения команды напрямую в программу с помощью конвейера (pipe):

`$ ls -l | python3 get_mean_size.py`

Напишите функцию `get_mean_size`, которая на вход принимает результат выполнения команды `ls -l`, а возвращает средний размер файла в каталоге.
### Советы и рекомендации
- **Конвейер (pipe)** — это механизм передачи данных со стандартного потока вывода одной программы на стандартный поток ввода другой программы. Пример запуска конвейера:

```
$ ls -R | grep "\.txt" | wc -w
  1)      2)             3)
```

1) Получаем рекурсивно все файлы в текущем каталоге.
2) Получаем из них файлы с расширением .txt.
3) Получаем общее количество слов в .txt-файлах.

- Получить входные данные можно следующим образом:

```python
import sys

data = sys.stdin.read()
```
Вывод можно делать с помощью того же print.
- Входные данные можно получить сразу в виде списка строк:

```python
lines = sys.stdin.readlines()
```
- Первая строка не является информацией о файле, поэтому её можно отбросить при прочтении входных данных:

```python
lines = sys.stdin.readlines()[1:]
```
- Кстати, программа также может получать информацию из файла и из результата выполнения другой команды или программы.

```
$ ls -l > ls.txt
$ python3 get_mean_size.py < ls.txt
$ cat ls.txt | python3 get_mean_size.py
```

`cat <filename>` выводит содержимое файла.

### Что оценивается
- Программа поддерживает обработку входных данных через конвейер.
- Программа обрабатывает случай, когда файлов нет или не удаётся получить их размер.
- Получение входных данных и вывод результата происходит в блоке `__main__`.

## Задача 3. Дешифратор
### Что нужно сделать
Вася решил передать Пете шифрограмму.<br>
Поскольку о промышленных шифрах Вася ничего не знает, он решил зашифровать сообщение следующим образом: он посылает Пете строку.

1. Каждый символ строки — либо буква, либо пробел, либо точка «.», либо две точки «..».
2. Если после какой-то буквы стоит точка, значит, мы оставляем букву без изменений (об одной точке Вася задумался, чтобы усложнить расшифровку). Саму точку при этом надо удалить.
3. Если после какой-то буквы стоят две точки, то предыдущий символ надо стереть. Обе точки при этом тоже нужно удалить.
4. Возможна ситуация, когда сообщение после расшифровки будет пустым. В качестве результата можно вернуть просто пустую строку.

| Шифровка                         | Расшифровка     |
|----------------------------------|-----------------|
| абра-кадабра.                    | абра-кадабра    |
| абраа..-кадабра                  | абра-кадабра    |
|  абраа..-.кадабра |  абра-кадабра   |
| абра--..кадабра | абра-кадабра    |
| абрау...-кадабра | абра-кадабра    |
| абра........ | <пустая строка> |
| абр......a. | a               |
| 1..2.3 | 23              |
| . | <пустая строка> |
| 1....................... | <пустая строка> |

Помогите Пете написать программу для расшифровки.<br>
Напишите функцию `decrypt`, которая принимает на вход шифр в виде строки, а возвращает расшифрованное сообщение.

Программа должна работать через конвейер (pipe):

```
$ echo 'абраа..-.кадабра' | python3 decrypt.py
абра-кадабра
```

Команда `echo` выводит текст (в стандартный поток вывода).
### Советы и рекомендации
- Рассмотрите несколько алгоритмов. Какой будет быстрее работать? Какой будет использовать меньше памяти?
- Не забудьте рассмотреть крайние случаи.
### Что оценивается
- Программа поддерживает обработку входных данных через конвейер.
- Программа правильно расшифровывает все примеры из условия.
- Получение входных данных и вывод результата происходит в блоке `__main__`.

## Задача 4. Хорошего дня!
### Что нужно сделать
Реализуйте endpoint `/hello-world/<имя>`, который возвращает строку «Привет, <имя>. Хорошей пятницы!». Вместо хорошей пятницы endpoint должен уметь желать хорошего дня недели в целом, на русском языке.

Пример запроса, сделанного в субботу:

`/hello-world/Саша`  →  Привет, Саша. Хорошей субботы!

### Советы и рекомендации
- Текущий день недели можно узнать так:

```python
from datetime import datetime
weekday = datetime.today().weekday()
```

Обратите внимание, что `weekday()` возвращает число от 0 до 6.
- Как лучше хранить названия дней недели? Посмотрите, сколько памяти занимают кортеж, список и словарь с одними и теми же данными с помощью метода getsizeof из модуля sys:

```python
import sys

print(sys.getsizeof(weekdays_tuple))
print(sys.getsizeof(weekdays_list))
print(sys.getsizeof(weekdays_dict))
```

### Что оценивается
- В понедельник endpoint желает хорошего понедельника, во вторник — вторника и так далее.
- При изменении имени в URL endpoint возвращает сообщение с изменённым именем.
- Выбран оптимальный способ хранения названий дней недели.

## Задача 5. Максимальное число
### Что нужно сделать
Реализуйте endpoint, начинающийся с `/max_number`, в который можно передать список чисел, разделённых слешем /. Endpoint должен вернуть текст «Максимальное переданное число {`number`}», где `number` — выделенное _курсивом_ наибольшее из переданных чисел.

Примеры:

`/max_number/10/2/9/1`<br>
Максимальное число: 10

`/max_number/1/1/1/1/1/1/1/2`<br>
Максимальное число: 2
### Советы и рекомендации
- Для обработки списка чисел, разделённых слешем, потребуется тип URL-параметра `path`.
- Так как пользователь может передать в параметры что угодно, нужно сделать дополнительную проверку — действительно ли переданы числа, а не что-то другое.
- Обратите внимание, что сравнивать строки неправильно:<br> 
`9 < 10`, но `'9' > '10'`

### Что оценивается
- В endpoint можно передать неограниченное количество чисел.
- Обрабатывается запрос, когда в URL передано не число.

## Задача 6. Превью файла
### Что нужно сделать
Реализуйте endpoint, который показывает превью файла, принимая на вход два параметра: `SIZE` (int) и `RELATIVE_PATH` — и возвращая первые `SIZE` символов файла по указанному в `RELATIVE_PATH` пути.

Endpoint должен вернуть страницу с двумя строками.<br>
В первой строке будет содержаться информация о файле: его абсолютный путь и размер файла в символах, а во второй строке — первые `SIZE` символов из файла:

```
<abs_path> <result_size><br>
<result_text>
```

где `abs_path` — написанный жирным абсолютный путь до файла;<br>
`result_text` — первые `SIZE` символов файла;<br>
`result_size` — длина `result_text` в символах.

Перенос строки осуществляется с помощью HTML-тега `<br>`.

Пример:

_docs/simple.txt:_<br>
hello world!

_/preview/8/docs/simple.txt_<br>
**/home/user/module_2/docs/simple.txt** 8<br>
hello wo

_/preview/100/docs/simple.txt_<br>
**/home/user/module_2/docs/simple.txt** 12<br>
hello world!
### Советы и рекомендации
- Абсолютный путь до файла можно узнать так:
- 
```python
import os
abs_path = os.path.abspath('<file_name>')
```
- Функция `file.read` также может принимать на вход количество символов, которое нужно прочитать:

`file.read(SIZE)`

Такой способ гораздо лучше обычного среза `file.read()[:SIZE]`, ибо не приходится читать файл целиком. Это полезно, когда файл имеет очень большой размер.
- Учтите, что приложение может быть запущено из другой директории, поэтому относительный путь может поменяться. Вспомните рекомендацию к endpoint `/get_random_word` из модуля 1.
### Что оценивается
- Отображается абсолютный, а не относительный путь.
- Результат возвращается с переносом строки и с заключённой в нужные HTML-теги информацией.
- Файл не считывается целиком.
- Размер и относительный путь имеют правильные URL-параметры.

## Задача 7. Учёт финансов
### Что нужно сделать
Реализуйте приложение для учёта финансов, умеющее запоминать, сколько денег было потрачено за день, а также показывать затраты за отдельный месяц и за целый год.

В программе должно быть три endpoints:

- **/add/<date>/\<int:number\>** — сохранение информации о совершённой в рублях трате за какой-то день;
- **/calculate/\<int:year\>** — получение суммарных трат за указанный год;
- **/calculate/\<int:year>\<int:month>** — получение суммарных трат за указанные год и месяц.

Дата для `/add/` передаётся в формате _YYYYMMDD_, где _YYYY_ — год, _MM_ — месяц (от 1 до 12), _DD_ — число (от 01 до 31). Гарантируется, что переданная дата имеет такой формат и она корректна (никаких 31 февраля).
### Советы и рекомендации
- У словаря есть метод `setdefault`, который возвращает значение по ключу, а если такого ключа нет, инициализирует элемент заданным значением.

Вариант с большим количеством вложенных условий:

```python
if year in storage:
    if month in storage[year]:
        storage[year][month] += expense
    else:
        ...
else:
    ...
```

Вариант с использованием `setdefault`:

```python
storage.setdefault(year, {}).setdefault(month, {})
storage[year][month] += expense
```

- Рассмотрите несколько вариантов хранения информации. Какой из них будет работать наиболее эффективно? Нужно ли каждый раз пересчитывать траты за год или месяц?
### Что оценивается
- Расчёт затрат оптимизирован по времени и памяти.
- Отсутствует большое количество вложенных условий.

## Что оценивается в практической работе
- Корректно обрабатываются ошибки, если на вход подаются неожидаемые данные.
- Названия переменных и функций имеют значащие имена.
- Запуск веб-сервера происходит в блоке __main__.

## Как отправить работу на проверку
Выполните домашнее задание в GitLab, напишите «Сделано» в форме ниже и нажмите кнопку «Отправить».
